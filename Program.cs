using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace cs_wpf_property_generator
{
  public class Program
  {
    public static void Main(String[] args)
    {
      if (!args.Any())
      {
        Console.WriteLine("Please see README.md for usage.");
        return;
      }

      foreach (var path in args.Select(Path.GetFullPath))
      {
        if (!File.Exists(path))
          throw new Exception($"The configuration file '{path}' does not exist.");

        var project = Project.GetProject(path);
        var headerComment = GetHeaderComment(path, project);

        if (project.Errors.Any())
        {
          /* Don't generate code when errors are present.
             just output the header comment (which contains
             the error messages), and process the next 
             configuration file. */
          project.Save(headerComment);
        }
        else
        {
          var output =
            new List<String>()
            {
              headerComment,
              GetUsings(project),
$@"namespace {project.Namespace}
{{
  [Serializable]
  public partial class {project.Classname}{GetInterfaceIdentifiers(project)}
  {{",
              GetInstanceConstructor(project).Indent(4),
              GetProperties(project).Indent(4),
              GetInterfaceImplementations(project).Indent(4),
@"  }
}"
            };

          project.Save(output.Where(s => !String.IsNullOrWhiteSpace(s)).Join("\n\n"));
        }
      }
    }

    private static String GetInstanceConstructor(Project project)
    {
      return project.ShouldImplementIChangeTracking ? $"public {project.Classname}() : base() => this.AcceptChanges();" : "";
    }

    private static String GetHeaderComment(String path, Project project)
    {
      var comments =
        new List<String>()
        {
          $@"/*

This code was generated by cs_wpf_property_generator.exe from
configuration file '{path}'.
on {DateTime.Now}.
 
Changes to this file may cause incorrect behavior and
will be lost if the code is regenerated.  Modify the
above listed configuration file instead and regenerate the code."
        };

      var lists =
        new[]
        {
          new { Description = "INFO:", Items = project.Info },
          new { Description = "WARNING(S):", Items = project.Warnings },
          new { Description = "ERROR(S):", Items = project.Errors },
        };

      foreach (var list in lists)
      {
        if (list.Items.Any())
        {
          comments.Add(list.Description);
          comments.AddRange(list.Items);
        }
      }

      comments.Add("*/");

      return comments.Join("\n\n");
    }

    private static String GetUsings(Project project)
    {
      return
        project
        .Usings
        .OrderBy(u => u)
        .Distinct()
        .Select(u => $"using {u};")
        .Join("\n");
    }

    private static String GetInterfaceIdentifiers(Project project)
    {
      var interfaceIdentifiers = new List<String>();

      if (project.ShouldImplementIChangeTracking)
        interfaceIdentifiers.Add("IChangeTracking");

      if (project.ShouldImplementINotifyPropertyChanged)
        interfaceIdentifiers.Add("INotifyPropertyChanged");

      var result = interfaceIdentifiers.Join(", ");

      return result.Any() ? " : " + result : "";
    }

    private static String GetIEnumerableChangedExpressions(IEnumerable<Property> properties)
    {
      var result = new List<String>() { "this._isChanged" };

      result.AddRange(
        properties
        .Where(p => p.IsIEnumerable)
        .Select(p => $"this.{p.Name}.Where(p => p is IChangeTracking).Any(p => (p as IChangeTracking).IsChanged)"));

      return result.Join(" ||\n");
    }

    private static String GetResetOriginalValuesCode(IEnumerable<Property> properties)
    {
      var foo =
        properties
        .Where(p => !p.IsIEnumerable)
        .OrderBy(property => property.Name)
        .Select(property => $"this._originalValues[nameof(this.{property.Name})] = this.{property.BackingStoreName};")
        .Join("\n");

      var code = new List<String>() { foo };

      const String template = @"foreach (var quux in this.{0}.Where(q => q is IChangeTracking))
  (quux as IChangeTracking).AcceptChanges();";

      foreach (var bar in properties.Where(p => p.IsIEnumerable))
        code.Add(String.Format(template, bar.Name));

      return code.Join("\n\n");
    }

    private static String GetInterfaceImplementations(Project project)
    {
      var result = new List<String>();

      if (project.ShouldImplementIChangeTracking)
        result.Add($@"private readonly Dictionary<String, Object> _originalValues = new Dictionary<String, Object>();

#region IChangeTracking
private Boolean _isChanged = false;
public Boolean IsChanged
{{
  get
  {{
    return
{GetIEnumerableChangedExpressions(project.Properties).Indent(6)};
  }}
  set
  {{
    this._isChanged = value;
  }}
}}

public void AcceptChanges()
{{
  this.IsChanged = false;

  /* Reset original values. */
{GetResetOriginalValuesCode(project.Properties).Indent(2)}
}}
#endregion");

      if (project.ShouldImplementINotifyPropertyChanged)
        result.Add($@"#region INotifyPropertyChanged
public event PropertyChangedEventHandler PropertyChanged;

protected void OnPropertyChanged(String name)
{{
  PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(name));
}}
#endregion");

      return result.Join("\n\n");
    }

    private static String GetPropertySetter(Project project, Property property)
    {
      var result = new List<String>() { $@"if (this.{property.BackingStoreName} == value)
  return;

this.{property.BackingStoreName} = value;" };

      if (project.ShouldImplementIChangeTracking)
        result.Add($@"if (this._originalValues.ContainsKey(nameof(this.{property.Name})))
  this.IsChanged = (value != ({property.Type}) this._originalValues[nameof(this.{property.Name})]);
else
  this.IsChanged = true;");

      if (project.ShouldImplementINotifyPropertyChanged)
        result.Add($"OnPropertyChanged(nameof(this.{property.Name}));");

      return result.Join("\n\n");
    }

    private static String GetProperty(Project project, Property property)
    {
      if (property.IsIEnumerable)
        return $"public {property.Type} {property.Name} {{ get; }} = new {property.Type}();";
      else
        return
$@"private {property.Type} {property.BackingStoreName} = {property.DefaultValue};
public {property.Type} {property.Name}
{{
  get
  {{
    return this.{property.BackingStoreName};
  }}
  set
  {{
{GetPropertySetter(project, property).Indent(4)}
  }}
}}";
    }

    private static String GetProperties(Project project)
    {
      return project.Properties.Select(property => GetProperty(project, property)).Join("\n\n");
    }
  }

  public class Project
  {
    public String Namespace { get; private set; } = default;
    public String Classname { get; private set; } = default;
    public Boolean ShouldImplementIChangeTracking { get; private set; } = default;
    public Boolean ShouldImplementINotifyPropertyChanged { get; private set; } = default;
    public List<Property> Properties { get; } = new List<Property>();
    public String OutputFilename { get; private set; } = default;
    public List<String> Usings { get; } = new List<String>() { "System", "System.ComponentModel", "System.Collections.Generic", "System.Linq" };
    public List<String> Info { get; } = new List<String>();
    public List<String> Warnings { get; } = new List<String>();
    public List<String> Errors { get; } = new List<String>();

    private Project()
      : base()
    {
    }

    public void Save(String output)
    {
      Directory.CreateDirectory(Path.GetDirectoryName(this.OutputFilename));
      File.WriteAllText(this.OutputFilename, output);
    }

    /* Remove comments and trim whitespace from line.

       Given the logic of the while loop in GetProject,
       it is guaranteed that 'line' is not null. */
    private static String GetSanitizedLine(String line)
    {
      var indexOfHash = line.IndexOf('#');

      return
        ((indexOfHash < 0)
        ? line
        : line.Substring(0, indexOfHash)).Trim();
    }

    private static String GetSectionName(String line) => line.Trim("[]".ToCharArray()).Trim();

    private enum State { Start, Namespace, Classname, Interfaces, Properties, OutputFilename, Usings }

    public static Project GetProject(String filename)
    {
      const Boolean caseInsensitiveComparison = true;
      var result = new Project();

      using (var inputfile = File.OpenText(filename))
      {
        String line = null;
        var state = State.Start;

        while ((line = inputfile.ReadLine()) != null)
        {
          line = GetSanitizedLine(line);

          if (String.IsNullOrWhiteSpace(line))
            continue;

          if (line.StartsWith("["))
          {
            if (Enum.TryParse(GetSectionName(line), caseInsensitiveComparison, out State newState))
            {
              state = newState;
              continue;
            }
            else
            {
              result.Errors.Add($"Unknown section name.  (Note that case and whitespace are not significant.  Something else is wrong.): '{line}'");

              /* Can't continue, as the code in the switch statement below assumes
                 the lines it's processing belong to a given section.  That assumption
                 may not be valid if there's an unrecognized section. */
              break;
            }
          }

          switch (state)
          {
            case State.Namespace:
              result.Namespace = line;
              break;
            case State.Classname:
              result.Classname = line;
              break;
            case State.Interfaces:
              if (line.ToLower() == "ichangetracking")
                result.ShouldImplementIChangeTracking = true;
              else if (line.ToLower() == "inotifypropertychanged")
                result.ShouldImplementINotifyPropertyChanged = true;
              else
                result.Errors.Add($"'{line}' is an unknown interface identifier in 'interfaces' section.  The only valid values are 'IChangeTracking' and 'INotifyPropertyChanged' (case insensitive).");

              break;
            case State.Properties:
              try
              {
                result.Properties.Add(new Property(line));
              }
              catch (Exception ex)
              {
                result.Errors.Add(ex.Message);
              }
              break;
            case State.OutputFilename:
              result.OutputFilename = Path.GetFullPath(Environment.ExpandEnvironmentVariables(line).Replace("\"", ""));
              break;
            case State.Usings:
              result.Usings.Add(line);
              break;
          }
        }
      }

      AddMessages(result);
      return result;
    }

    private static void AddMessages(Project project)
    {
      /* Validate the project's properties.
         Add any necessary info, warning, and/or error messages. */

      if (project.Namespace == default)
        project.Errors.Add("The [namespace] section is either missing or it has no entry.");

      if (project.Classname == default)
        project.Errors.Add("The [classname] section is either missing or it has no entry.");

      if (!project.ShouldImplementIChangeTracking && !project.ShouldImplementINotifyPropertyChanged)
        project.Info.Add("No interfaces were specified.  This is OK, but note that only ordinary property code has been generated.");

      if (!project.Properties.Any())
        project.Warnings.Add("No properties were specified.  This is OK, but note that no property code has been generated.");

      if (project.ShouldImplementIChangeTracking)
          project.Info.Add(@"A parameterless constructor has been generated.

This constructor calls the object's IChangeTracking.AcceptChanges() method,
which initializes an internal data structure needed to implement correct change-tracking logic.
Note that another parameterless constructor cannot be created in a partial class of this class.");
    }
  }

  public class Property
  {
    public Boolean IsIEnumerable { get; private set; }
    public String Type { get; private set; }
    public String DefaultValue => (this.Type.ToLower() == "string") ? "\"\"" : "default";
    public String Name { get; private set; }
    public String BackingStoreName { get; private set; }

    public Property(String typeAndName)
      : base()
    {
      var parts = typeAndName.Split(" ".ToCharArray(), StringSplitOptions.RemoveEmptyEntries);
      if (parts.Length == 3)
      {
        var isEnumerableFlag = parts[0].ToLower();

        if (isEnumerableFlag != "x")
          throw new Exception($"This property specification has three parts, but the first part isn't an 'x': {typeAndName}");

        this.IsIEnumerable = true;
        this.Type = parts[1].Trim();
        this.Name = parts[2].Trim();
      }
      else if (parts.Length == 2)
      {
        this.IsIEnumerable = false;
        this.Type = parts[0].Trim();
        this.Name = parts[1].Trim();
      }
      else
      {
        throw new Exception($"Don't know how to handle this property specification: {typeAndName}");
      }

      var firstLetterOfName = Char.ToLower(this.Name[0]);
      var restOfName = this.Name[1..];
      this.BackingStoreName = $"_{firstLetterOfName}{restOfName}";
    }
  }
}
